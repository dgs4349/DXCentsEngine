

////////// old initialize ///////////////

soundEngine->Init();
// loading audio here for now
bgIntro = soundEngine->CreateSound(L"Assets/Audio/audio_background_intro.wav");
bgLoop = soundEngine->CreateSound(L"Assets/Audio/audio_background_loop.wav", true);
bgIntro->Link(bgLoop);
bgIntro->Set(0.35f);

Sound::RTPCParams* introParams = bgIntro->CreateRTPCParams();

bgIntro->Bind(introParams->pitch, &ropeSpeed, -0.01f, 0.75f, startRopeSpeed, speedIncreaseMax);

menuIntro = soundEngine->CreateSound(L"Assets/Audio/audio_menu_intro.wav");
menuLoop = soundEngine->CreateSound(L"Assets/Audio/audio_menu_loop.wav", true);
menuIntro->Link(menuLoop);
menuIntro->Set(menuVolume);
menuIntro->PlayOnUpdate();

jumpSfx.push_back(soundEngine->CreateSound(L"Assets/Audio/sfx/jump_0.wav"));
jumpSfx.push_back(soundEngine->CreateSound(L"Assets/Audio/sfx/jump_1.wav"));
jumpSfx.push_back(soundEngine->CreateSound(L"Assets/Audio/sfx/jump_2.wav"));
jumpSfx.push_back(soundEngine->CreateSound(L"Assets/Audio/sfx/jump_3.wav"));
for (int i = 0; i < jumpSfx.size(); i++) jumpSfx[i]->Set(0.5f, 0.0f, 0.95f);


//////////////// new initialize /////////////////


// json literal string format
Scene game = new Scene(R"(
	{
		"$background": SoundContainer({
			"files": {
				L"Assets/Audio/audio_background_intro.wav",
				L"Assets/Audio/audio_background_loop.wav"
			}
			"volume": 0.35f,
			"effects": {
				backgroundVolume: {'v': { 0.5f, 1.5f }}
			}
			"OnComplete": Effects.Container.LoopLast(),
		}),

		"OnStart": "background",
		"3D": false,

		(or ListenerPostition:, and with sound just Position, Velocity, etc)


	}
)"_json);

// json struct format
Scene menu = new Scene({
	{"background", ""}
});

// or this could be in a scene
SoundContainer* SFX = new SoundContainer({
	{"jump", 
		{"files", L"Assets/Audio/sfx/jump_|0-4-1|.wav"}, // schema parser
		{"volume", 0.5f},
		{"pan", 0.95f},
		{"index", "sequential"}
	}
});

SFX["jump"]->Play(); //goal, one offs invoked without member play?


/** Notes
!!!! syntax:
	each object begin, if key is a class we know, begin parsing accordingly
	!!!!!!!!!all system params should begin with a capital, all user variables should be lowercase

instead of this:
	SoundContainer* SFX = new SoundContainer({
		{"jump", 
			{"files", L"Assets/Audio/sfx/jump_|0-4,1|.wav"}, // schema parser
			{"volume", 0.5f},
			{"pan", 0.95f},
			{"index", "sequential"}
		}
	});

this:
	SoundContainer* SFX = new SoundContainer({
		{"_jump", 
			Group{
				"Files", L"Assets/Audio/sfx/jump_|0-4,1|.wav", // schema parser
				"Volume", 0.5f,
				"Pan", 0.95f,
				"Index", "sequential"
			}
		
		}
	});

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	names MUST begin with a non-alpha character, a non alpha character of

	SoundContainer* SFX = new SoundContainer({
		{"\jump", 
		{"$jump", 
		{"!jump", 
		{"_jump", 

			group{
				"files", L"Assets/Audio/sfx/jump_|0-4,1|.wav", // schema parser
				"volume", 0.5f,
				"pan", 0.95f,
				"index", "sequential"
			}
			
		}
	});



new class: Group => plural sounds with identical parameters (files:"|~~|" or files:[] instead of file:"~~");
				 => like a container but all sounds are identical and parsed together
				 => either this or SoundContainer works, but Group can be parsed together and more compact declaring params, its just easier

SoundContainers can be recursive, this is fine

but make these macros, or could they replace the whole "volume": 3 and so on?
would doing a fuck ton of macros just make this whole thing easier?

Container.Indexs.Sequential
Containers.Wrap = true;

indexs: sequential, reverse, random, randomother, 
wrap: true (default), false, doesn't affect random containers
obvi we can do more but this is good for now

|0-4-1|, |0-4| from, to
|a, b, c|, each

file: parse string
files: parse group
parse(files names) {
	length > 1
		parse each
	length = 1
		regex split | -> only have one, make a note of that
			try regex split -
				for(args) do parse, [0]+n+[2] of filename
			try regex split ,
				foreach(args) do parse [0]+i+[2]of filename



// FILES SHOULD ALWAYS BE AN ARRAY

so, SoundContainer{
	Sounds{
		//multiple sounds
	}
	Files{
		// this is now a sound group instead of a sound container
		//		note: no need to parse vars since we expect vars to adjust played sounds

	}
}












details on json format and syntax


Scene game = new Scene(R"(
	{
		"$background": {
			"files": {
				L"Assets/Audio/audio_background_intro.wav",
				L"Assets/Audio/audio_background_loop.wav"
			}
			"volume": 0.35f,


			// effects will for now need to be made externally
			"effects": {
				new Effect(
					Effects.Volume(-0.0f, 0.75f), 
					Connect(&ropeSpeed, startRopeSpeed, speedIncreaseMax)
				),
				"$name": {"v", -0.0f, 0.75f},
				"name2": {"t", 1.0f, 10.0f},
			}


			"OnComplete": Effects.Container.LoopLast(),
			
		}
		
		
		talking this out, how do we determine what is and isnt a sound container

		honestly we could do it automatically, but that might be difficult
			- we'd need to either have SoundObject figure out if it's a SoundContainer
				- that would require SoundContainer being included in SoundObject
				- we would then need to either forward declare or somehow make soundcontainer
					a different beast altogether

		but the bottom line is that doing it automatically makes it harder to read for the client

		so, lets do this (pretend all items are strings)

		$background {
			Container {
				"files": {
					L"Assets/Audio/audio_background_intro.wav",
					L"Assets/Audio/audio_background_loop.wav"
				}
				"volume": 0.35f,
				"effects": {
					new Effect(
						Effects.Volume(-0.0f, 0.75f), 
						Connect(&ropeSpeed, startRopeSpeed, speedIncreaseMax)
					),
				}
				"OnComplete": Effects.Container.LoopLast(),
			}
		}

		&bg {
			Container {
				items: {
					Container {
						file: a,
						v: -5
					}
					$guesswho {
						file: dlksjf

					}
					
					check: is items array or object
					doesn't have to be if object
						- since that can just be in base Container class

				}
			}
		}




		$background {
			Container {
				{
				"file": L"Assets/Audio/audio_background_intro.wav",
				"volume": 0.35f,
				"effects": {
					new Effect(
						Effects.Volume(-0.0f, 0.75f), 
						Connect(&ropeSpeed, startRopeSpeed, speedIncreaseMax)
					),
				}
				"OnComplete": Effects.Container.LoopLast(),
				}
				
			}
		}

		// maybe it's a scene, etc.
			shit speaking of, we will need to figure out what is and isnt a scene
			but im pretty sure that will just be scenes added to sound engine seperately
			and no need to complicate it further

		$background {
			Scene {
				"files": {
					L"Assets/Audio/audio_background_intro.wav",
					L"Assets/Audio/audio_background_loop.wav"
				}
				"volume": 0.35f,
				"effects": {
					new Effect(
						Effects.Volume(-0.0f, 0.75f), 
						Connect(&ropeSpeed, startRopeSpeed, speedIncreaseMax)
					),
				}
				"OnComplete": Effects.Container.LoopLast(),
			}
		}

		
		
		
		SoundContainer({
			"files": {
				L"Assets/Audio/audio_background_intro.wav",
				L"Assets/Audio/audio_background_loop.wav"
			}
			"volume": 0.35f,
			"effects": {
				new Effect(
					Effects.Volume(-0.0f, 0.75f), 
					Connect(&ropeSpeed, startRopeSpeed, speedIncreaseMax)
				),
			}
			"OnComplete": Effects.Container.LoopLast(),
		}),

		"OnStart": "background",
		"3D": false,

		(or ListenerPostition:, and with sound just Position, Velocity, etc)


	}
)"_json);

**/